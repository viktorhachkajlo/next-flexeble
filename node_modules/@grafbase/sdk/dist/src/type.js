"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeExtension = exports.Type = void 0;
var field_1 = require("./field");
var cache_1 = require("./typedefs/cache");
var validation_1 = require("./validation");
/**
 * A composite type definition (e.g. not a model).
 */
var Type = /** @class */ (function () {
    function Type(name) {
        (0, validation_1.validateIdentifier)(name);
        this._name = name;
        this.fields = [];
        this.interfaces = [];
    }
    Object.defineProperty(Type.prototype, "name", {
        /**
         * The name of the type.
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Pushes a field to the type definition.
     *
     * @param name - The name of the field.
     * @param definition - The type definition with optional attributes.
     */
    Type.prototype.field = function (name, definition) {
        this.fields.push(new field_1.Field(name, definition));
        return this;
    };
    /**
     * Pushes an interface implemented by the type.
     *
     * @param iface - The interface this type implements.
     */
    Type.prototype.implements = function (iface) {
        this.interfaces.push(iface);
        return this;
    };
    /**
     * Sets the type `@cache` directive.
     *
     * @param params - The cache definition parameters.
     */
    Type.prototype.cache = function (params) {
        this.cacheDirective = new cache_1.TypeLevelCache(params);
        return this;
    };
    Type.prototype.toString = function () {
        var _a;
        var interfaces = this.interfaces.map(function (i) { return i.name; }).join(' & ');
        var cache = this.cacheDirective ? " ".concat(this.cacheDirective) : '';
        var impl = interfaces ? " implements ".concat(interfaces) : '';
        var header = "type ".concat(this.name).concat(cache).concat(impl, " {");
        var fields = distinct(((_a = this.interfaces.flatMap(function (i) { return i.fields; })) !== null && _a !== void 0 ? _a : []).concat(this.fields))
            .map(function (field) { return "  ".concat(field); })
            .join('\n');
        var footer = '}';
        return "".concat(header, "\n").concat(fields, "\n").concat(footer);
    };
    return Type;
}());
exports.Type = Type;
var TypeExtension = /** @class */ (function () {
    function TypeExtension(type) {
        if (type instanceof Type) {
            this.name = type.name;
        }
        else {
            (0, validation_1.validateIdentifier)(type);
            this.name = type;
        }
        this.queries = [];
    }
    /**
     * Pushes a query to the extension.
     *
     * @param query - The query to be added.
     */
    TypeExtension.prototype.query = function (query) {
        this.queries.push(query);
        return this;
    };
    TypeExtension.prototype.toString = function () {
        if (this.queries.length > 0) {
            var queries = this.queries.map(String).join('\n');
            return "extend type ".concat(this.name, " {\n").concat(queries, "\n}");
        }
        else {
            return '';
        }
    };
    return TypeExtension;
}());
exports.TypeExtension = TypeExtension;
function distinct(fields) {
    var found = new Set();
    return fields.filter(function (f) {
        if (found.has(f.name)) {
            return false;
        }
        else {
            found.add(f.name);
            return true;
        }
    });
}
